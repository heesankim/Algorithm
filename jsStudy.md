function solution(n) {
var answer = 0;
const arr = [...String(n)];

answer = arr
.map(Number)
.reduce((accumulator, current) => accumulator + current, 0);
// [실행] 버튼을 누르면 출력 값을 볼 수 있습니다.
// console.log('Hello Javascript')

return answer;
}
console.log(solution(12345)) // 15

---

const myNumber = 23

- 변수는 myNumber
- 해당 값의 위치(메모리주소) : 0012CCGWH80 등 어딘가
- 변수 값( 저장된 값 ): 23

- 자바스크립트는 매니지드 언어이기 때문에 개발자가 직접 메모리 제어 할 수 없음.

- C언어와 같은 로우 레벨 언어에서는 메모리 관리를 위해 malloc()과 free()을 사용

- 자바스크립트는 객체가 생성되었을 때 자동으로 메모리를 할당하고 쓸모 없어졌을 때 자동으로 해제한다.

- 이러한 기능이 가비지 컬렉션(Garbage Collection)이라고 한다.

- 이러한 점은 기능에 있어 잠재적 혼란의 원인을 발생시킬 수도 있다.

- 💡개발자가 직접 변수를 선언해서 쓰니까, 메모리 할당도 명시적으로 사용하는 것 아닌가요?

- const name = "inyong"와 같은 코드를 보고 '개발자가 직접 메모리 할당해주는 것 아니냐'라고 생각하면 안 된다. 저것 또한 변수를 선언함으로써 메모리를 자동으로 할당해준 것이기 때문이다. (위에 살짝 설명한 C언어 코드 참조.)

var str = 'Hello';
str = 'world';

1번라인이 실행되면 문자열 Hello가 생성되고 str은 메모리에 문자열 메모리 주소를 가리킨다.
2번라인이 실행되면 문자열 world가 생성되고 str은 메모리에 해당 문자열 주소를 가리킨다.
즉, Hello 문자열이 변경되는 것이 아니라 world, Hello 각각 메모리에 할당된다.

- Boolean 타입은 단 1bit

- Number 타입 : 숫자의 자료형은 정수,소수 상관없이 무조건 64bit(=8byte)

- 자바스크립트에서는 String 타입은 한 문자 당 16Bit

<자바스크립트에서 더 이상 필요 없는 메모리를 해제>

- 문제는 할당된 메모리가 더 이상 필요 없을 때"를 알아내기가 어렵다는 것

- 가비지 컬렉션의 목적은 '메모리 할당을 추적하고 할당된 메모리 블록이 더 이상 필요하지 않은지를 판단하여 회수하는 것

- 가비지 컬렉션은 위에서 말한 것처럼, 할당된 메모리 블록이 더 이상 필요하지 않은지 판단해야 된다고 했었는데 이러한 판단하는 핵심 개념은 '참조'이다

-A라는 메모리를 통해 B라는 메모리에 접근할 수 있다면 "B는 A에 참조된다"라고 한다. 예를 들어 모든 자바스크립트 오브젝트는 "prototype"을 암시적으로 참조하고 그 오브젝트의 속성을 명시적으로 참조한다.

- 참조-세기(Reference-counting) 가비지 컬렉션

- 참조-세기 알고리즘은 가장 소박한 알고리즘이다.

- 여기서는 '어떤 다른 오브젝트에서도 참조하지 않는 오브젝트'를 더 이상 필요하지 않은 메모리로 판단하여 메모리를 해제한다.

- 이러한 자바스크립트 내 '참조'의 개념에서도, '참조를 하지 않는다'라고 판단하는 조건이 여러 가지가 있는데, 아래에서 하나씩 알아보자.

- 자바스크립트는 기존의 객체를 복사하여(cloning) 새로운 객체를 생성하는 프로토타입 기반의 언어임

- 프로토타입 기반 언어는 객체 원형인 프로토타입을 이용하여 새로운 객체를 만들어냄

- 프로토타입 객체란? -> 자신이 다른 객체의 원형이 되는 객체 . 모든 객체는 프로토타입 객체에 접근 가능

- 생성된 객체 역시 또 다른 객체의 원형이 될 수 있음.

- 프로토타입은 객체를 확장하고 객체 지향적인 프로그래밍을 할 수 있게 해줌

- 프로토타입은 크게 두 가지로 해석됨

- 프로토타입 객체를 참조하는 prototype 속성과 객체 멤버인 prototype 속성이 참조하는 숨은 링크가 있음

< 변수 할당 >

- 자바스크립트 엔진은 소스코드를 한줄씩 순차적으로 실행하는 인터프리터 언어임.
- 변수 선언이 어디에 있든 상관없이 다른 코드보다 먼저 실행되는 특징을 호이스팅 이라고 함
- 변수 선언 포함한 모든 선언문을 호이스팅하여 런타임 이전에 실행됨.
  (ex.var,let,const,function,function\*,class)

- 변수의 선언은 var, const, let 키워드로 할 수 있으며, ES6에서 const와 let이 추가되었다.

- 자바스크립트에서 변수 선언은 선언 → 초기화 단계를 거쳐 수행된다.

- 선언 단계: 변수명을 등록하여 자바스크립트 엔진에 변수의 존재를 알린다.
- 초기화 단계: 값을 저장하기 위한 메모리 공간을 확보하고 암묵적으로 undefined를 할당해 초기화한다.

\*\* 💡var 를 통한 변수 선언은 선언단계와 초기화 단계 동시 진행. 암묵적으로 undefined를 할당해 초기화 함

= 은 같다는 표시가 아니라 할당연산자임.
\*\* 재할당은 변수에 저장된 값을 다른 값으로 변경하는 것으로, 만약 변경 할 수 없는 값이라면 이는 변수가 아니라 상수라 부름.

💡💡
함수 선언문은 런타임 이전에 자바스크립트 엔진에서 먼저 실행되어서 함수 자체를 호이스팅 시킬 수 있다.
but 함수 표현식은 변수 호이스팅과 같이 런타임 이전에 해당 값을 undefined로 초기화만 시키고
해당 함수 표현식이 할당되어 그때 객체가 된다.
💡💡

< 스코프 >

- 스코프(scope)는 식별자(ex.변수명,함수명,클래스명 등)의 유효범위를 뜻함.
- 선언된 위치에 따라 유효 범위가 달라짐
- 젼역에 선언된 변수는 전역 스코프, 지역에 선언된 변수는 지역 스코프
- 전역 변수는 어디에서든지 참조가 가능한 값
- 반면,지역 변수는 함수 몸체 내부. 따라서 지역 변수는 자신의 지역 스코프와 그 하위 지역 스코프에만 유효

한 가지 주의해야 할 점은, 자바스크립트에서 모든 코드 블록(if, for, while, try/catch 등)이 지역 스코프를 만들며, 이러한 특성을 블록 레벨 스코프라 한다. 하지만 var 키워드로 선언된 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정한다. 이를 함수 레벨 스코프라 한다.

💡💡💡💡💡💡💡💡💡💡💡💡💡💡
var a = 1

if (true) {
var a = 5
}

console.log(a) // output: 5
함수가 아닌 곳에서 var 키워드를 이용해 a를 선언했기 때문에 전역 변수로 취급한다. 기존에 있던 a 변수가 중복 선언되면서, 최하단의 console에서도 출력 값이 5로 바뀐 것을 확인할 수 있다.

해당 예제는 코드가 짧아서 어디에서 문제가 일어난지 바로 알 수 있었지만, 실무에서는 그렇지 않다. 전역 변수로 인해 재할당이 발생하거나, 전역 스코프를 공유하기 때문에 어딘가에 동일한 이름이 있다면 예상치 못한 결과를 가져올 수 있는 위험이 있다. 따라서 오로지 함수 코드 블록만을 지역 스코프로 인정하는 var 대신, 블록 레벨 스코프를 지원하는 const와 let을 사용하는 것을 권장한다.

var, let, const의 차이
앞에서 발견한 var 키워드의 문제점은 크게 세 가지가 존재한다.

변수 중복 선언 가능하여, 예기치 못한 값을 반환할 수 있다.
함수 레벨 스코프로 인해 함수 외부에서 선언한 변수는 모두 전역 변수로 된다.
변수 선언문 이전에 변수를 참조하면 언제나 undefined를 반환한다.

ES6에서 나온 let과 const 키워드는 위의 세 가지 문제점을 해결했다.

1. 변수 중복 선언 불가
   (1) let

let 키워드로는 변수 중복 선언이 불가하지만, 재할당은 가능하다.

```
let name = 'kmj'
console.log(name) // output: kmj

let name = 'howdy' // output: Uncaught SyntaxError: Identifier 'name' has already been declared

name = 'howdy'
console.log(name) // output: howdy
```

(2) const

const가 let과 다른 점이 있다면, 반드시 선언과 초기화를 동시에 진행되어야 한다.

const name; // output: Uncaught SyntaxError: Missing initializer in const declaration
const name = 'kmj'

const도 let과 마찬가지로 재선언이 불가하며, 더 나아가 재할당도 불가하다. 재할당의 경우, 원시 값은 불가능하지만, 객체는 가능하다. const 키워드는 재할당을 금지할 뿐, '불변'을 의미하지 않는다.

```
// 원시값의 재할당
const name = 'kmj'
name = 'howdy' // output: Uncaught TypeError: Assignment to constant variable.

// 객체의 재할당
const name = {
  eng: 'kmj',
}
name.eng = 'howdy'
console.log(name) // output: { eng: "howdy" }
```

💡💡💡💡💡💡💡💡💡💡💡💡💡💡
let, const 키워드로 선언한 변수는 모두 코드 블록(ex. 함수, if, for, while, try/catch 문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따른다.
위 var 키워드로 예를 들었던 것을 그대로 가져와 바꾸면 아래와 같은 결과가 나온다.

let a = 1

if (true) {
let a = 5
}

console.log(a) // output: 1
var 키워드로 선언한 경우 5가 나왔지만, let 키워드로 선언한 경우 if 문 안에 있는 것은 지역 스코프를 가져 전역에서 console을 찍었을 경우, 전역에 있는 a가 결과 값으로 출력된다. (const 키워드도 let 키워드와 동일하게 동작한다)

3. 변수 호이스팅
   (1) let

let 키워드로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행된다. 즉, 런타임 이전에 자바스크립트 엔진에 의해 선언 단계가 먼저 실행되지만, 초기화 단계가 실행되지 않았을 때 해당 변수에 접근하려고 하면 참조 에러가 뜬다.

console.log(name) // output: Uncaught ReferenceError: name is not defined

let name = 'kmj'
따라서 let 키워드로 선언한 변수는 스코프의 시작 지점부터 초기화 단계 시작 지점까지 변수를 참조할 수 없는 일시적 사각지대(Temporal Dead Zone: TDZ) 구간에 존재한다.

(2) const

const 키워드는 선언 단계와 초기화 단계가 동시에 진행된다.

console.log(name) // output: Uncaught ReferenceError: Cannot access 'name' before initialization

const name = 'kmj'
let 키워드로 선언한 경우, 런타임 이전에 선언이 되어 자바스크립트 엔진에 이미 존재하지만 초기화가 되지 않았기 때문에 name is not defined라는 문구가 떴다. 하지만 const 키워드로 선언한 경우, 선언과 초기화가 동시에 이루어져야 하지만 런타임 이전에는 실행될 수 없다. 따라서 초기화가 진행되지 않은 상태이기 때문에 Cannot access 'name' before initialization 에러 문구가 뜬다.

정리
기본적으로 변수의 스코프는 최대한 좁게 만드는 것을 권장한다. 따라서, var 키워드 보다는 let과 const 키워드를 사용하며, 변경하지 않는 값(상수)이라면 let 보다는 const 키워드를 사용하는 것이 안전하다.
